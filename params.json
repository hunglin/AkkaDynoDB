{"name":"Akkadynodb","tagline":"Dynamo like distributed database built using Akka Cluster","body":"AkkaDynoDB (Reactive Storage Service)\r\n==========================================================\r\n\r\nDynamo like distributed database built using Akka Cluster\r\n\r\n## **Introduction**\r\n\r\n_**AkkaDynoDB**_ is a _reactive_ _storage_ _service_ inspired from the Amazon dynamo distributed database\r\nwhich is Highly available, scalable and resilient database [All Things distributed Paper](http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf).\r\nWith changing requirements of enterprise applications the way we build applications has been changing. With increasing number of\r\ndevices that connect to the internet the traffic per server has drastically changed over years and its going to increase much more in the\r\nnear future with the emergence of Internet of things(IOT). In order to cater to the changing requirements which cannot be handled by traditional architectures\r\nmany enterprises started adopting distributed architectures to spread load over large number of machines and handle user requests. These applications should also\r\nhandle data effectively and offer reliability to its users. As the number of users increasing the applications must also scalable well \r\naccording to the need. Not only scalability and reliability users also expect 100% availability that means 0 down times even in case of \r\ndatabase maintenance and data migration. In order to offer these essential features enterprises have been adopting certain best practices and techniques from \r\ndifferent researches. _**Reactive design principles**_ basically convey these best practices and how systems should be built from ground up to be scalable,\r\navailable and be resilient.\r\n\r\n## **Reactive Systems**\r\n \r\n_**Reactive Systems**_ has these four traits\r\n\r\n1. Responsive     (Available in a responding state)\r\n\r\n2. Resilient      (Fault tolerant)\r\n\r\n3. Elastic        (Scalable)\r\n\r\n4. Message Driven (Communicate by sending messages i.e core to distribution)\r\n\r\nPlease read [Reactive Manifesto](http://www.reactivemanifesto.org/) to know about what is to be reactive.\r\n\r\n## **Akka**\r\n\r\n_**Akka**_ as mentioned here [akka.io](http://akka.io) is a toolkit and runtime for building \r\n\r\n1. Highly Concurrent\r\n\r\n2. Distributed\r\n\r\n3. Resilient\r\n\r\n4. Message-Driven  applications on JVM (Java Virtual Machine)\r\n\r\nAkka adheres to the reactive principles and offers abstractions to deal with concurrency, distribution and fault tolerance.\r\n\r\n1. For concurrency Akka offers Scala Futures and Agents.     (Helps Scale up)\r\n\r\n2. For Distribution and Remoting it offers Actors.           (Helps Scale Out)\r\n\r\n3. For Fault tolerance Actor Supervision.                    (Deal with Failure)\r\n\r\nNote: The above mentioned is not exhaustive list of what akka offers. Please visit [Akka Website](http://akka.io) for more.\r\n\r\nMore about actors [Actor Model](http://arxiv.org/pdf/1008.1459.pdf), [Actor Model](http://publications.csail.mit.edu/lcs/pubs/pdf/MIT-LCS-TR-194.pdf).\r\n\r\n## **Actor**\r\n\r\n_**Actor Model**_ of concurrent computation provides a primitive called as **Actor**. \r\n\r\nActor is an entity which can do these three things\r\n\r\n1. Communicate with message passing (can communicate)\r\n\r\n2. Create new actors (Can create new actors)\r\n\r\n3. decide what to do with next message (Can change its behaviour on receiving a message)\r\n\r\nActors can also have mutable state and can take local decisions. Actors can be used for distributing work among different machines.\r\nWith the help of actors work can be distributed among other worker actors and performed in a concurrent and distributed manner.\r\nActors provide location transparency by which same semantics of communication that are used for local actors can be used with remote actors.\r\nRunning potential long running code inside the actor makes the actor deaf to the messages that are sent to it. So, it is recommend to\r\nwrap long running code inside a Future and execute it.Akka provides handy syntax to do the same.\r\n\r\n\r\n  ```scala\r\n  \r\n  object MasterActor {\r\n      case object StartWork\r\n  }\r\n\r\n  class MasterActor extends Actor with ActorLogging {\r\n      def receive = {\r\n          case StartWork => {\r\n              val future = Future {\r\n                 longRunningCode\r\n             }\r\n             future pipeTo self //pipe feature\r\n          }\r\n          case _ => log.info(\"unknown message\")\r\n      }\r\n      def longRunningCode: Unit = Thread.sleep(1000000)\r\n  }\r\n  \r\n  ```\r\n  \r\n  \r\n\r\n\r\n ","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}